---
tags:
  - 外部化配置
  - 配置文件
  - 环境变量
  - 命令行参数
  - 配置优先级
  - Spring Boot
created: 2025-11-16
modified: 2025-11-16
category: 配置管理
difficulty: intermediate
---

# Spring Boot 外部化配置详解

## 目录
- [外部化配置概述](#外部化配置概述)
- [配置源优先级](#配置源优先级)
- [配置文件外部化](#配置文件外部化)
- [环境变量配置](#环境变量配置)
- [命令行参数配置](#命令行参数配置)
- [JVM系统属性](#jvm系统属性)
- [配置文件位置](#配置文件位置)
- [外部化配置最佳实践](#外部化配置最佳实践)

---

## 外部化配置概述

### 什么是外部化配置

> [!IMPORTANT] 核心概念
> **外部化配置**是指将应用程序的配置信息从代码中分离出来，通过外部配置源来管理，使得同一份代码可以在不同环境中运行而无需修改代码。

### 外部化配置的优势

1. **环境分离**：同一套代码可以部署到开发、测试、生产环境
2. **配置安全**：敏感信息（如数据库密码）不需要硬编码在代码中
3. **运维友好**：运维人员可以调整配置而不需要重新编译代码
4. **容器化支持**：完美适配 Docker、Kubernetes 等容器化部署
5. **配置中心集成**：可以与配置中心（如 Spring Cloud Config）集成

---

## 配置源优先级

Spring Boot 外部化配置按以下优先级加载（优先级从高到低）：

### 1. 命令行参数
```bash
java -jar myapp.jar --server.port=9090 --spring.profiles.active=prod
```

### 2. Java 系统属性
```bash
java -Dserver.port=9090 -Dspring.profiles.active=prod -jar myapp.jar
```

### 3. 操作系统环境变量
```bash
export SERVER_PORT=9090
export SPRING_PROFILES_ACTIVE=prod
java -jar myapp.jar
```

### 4. 外部配置文件
```
./config/application.properties
./application.properties
classpath:/config/application.properties
classpath:/application.properties
```

### 5. @PropertySource 注解
```java
@PropertySource("classpath:custom.properties")
```

### 6. 默认属性
Spring Boot 内置的默认配置

### 配置优先级示例

```java
@Component
public class ConfigurationPriorityDemo {

    @Autowired
    private Environment environment;

    @PostConstruct
    public void demonstratePriority() {
        // 假设多个配置源都定义了 server.port
        // 命令行参数会覆盖其他配置源
        System.out.println("Effective Server Port: " +
            environment.getProperty("server.port"));
    }
}
```

---

## 配置文件外部化

### 1. 外部配置文件位置

Spring Boot 会按以下顺序查找配置文件：

```
myapp/
├── config/                    # 优先级最高
│   └── application.properties
├── application.properties     # 第二优先级
└── myapp.jar
    ├── BOOT-INF/
    │   └── classes/
    │       ├── config/        # 第三优先级
    │       │   └── application.properties
    │       └── application.properties  # 优先级最低
```

### 2. 指定配置文件位置

#### 通过命令行参数指定
```bash
java -jar myapp.jar --spring.config.location=classpath:/default.properties,/opt/app/config/custom.properties
```

#### 通过配置文件指定
```yaml
# application.yml
spring:
  config:
    location: classpath:/default.properties,/opt/app/config/custom.properties
    additional-location: /opt/app/override/
```

### 3. 配置文件命名规则

```bash
# 支持的配置文件名
application.properties
application.yml
application.yaml

# Profile 特定配置
application-dev.properties
application-dev.yml
application-prod.properties
application-prod.yml
```

### 4. 外部配置文件示例

#### 开发环境配置 (`application-dev.yml`)
```yaml
spring:
  config:
    activate:
      on-profile: dev

  datasource:
    url: jdbc:h2:mem:devdb
    username: sa
    password:
    driver-class-name: org.h2.Driver

  jpa:
    show-sql: true
    hibernate:
      ddl-auto: create-drop

logging:
  level:
    root: DEBUG
    com.example.myapp: DEBUG

app:
  name: "MyApp - Development"
  debug: true
  cache:
    enabled: false
```

#### 生产环境配置 (`application-prod.yml`)
```yaml
spring:
  config:
    activate:
      on-profile: prod

  datasource:
    url: ${DATABASE_URL}
    username: ${DB_USER}
    password: ${DB_PASSWORD}
    driver-class-name: com.mysql.cj.jdbc.Driver
    hikari:
      maximum-pool-size: 20
      minimum-idle: 5
      connection-timeout: 30000

  jpa:
    show-sql: false
    hibernate:
      ddl-auto: validate

logging:
  level:
    root: WARN
    com.example.myapp: INFO
  file:
    name: /var/log/myapp/application.log
  logback:
    rollingpolicy:
      max-file-size: 100MB
      max-history: 30

app:
  name: "MyApp - Production"
  debug: false
  cache:
    enabled: true
    ttl: 3600
```

---

## 环境变量配置

### 1. 基本环境变量

```bash
# 服务器配置
export SERVER_PORT=8080
export SERVER_SERVLET_CONTEXT_PATH=/api

# 数据库配置
export SPRING_DATASOURCE_URL=jdbc:mysql://localhost:3306/mydb
export SPRING_DATASOURCE_USERNAME=root
export SPRING_DATASOURCE_PASSWORD=secret

# 应用配置
export APP_NAME=MyApplication
export APP_VERSION=1.0.0
export APP_CACHE_ENABLED=true
```

### 2. 环境变量命名规则

Spring Boot 会将环境变量转换为配置属性：

| 环境变量 | 配置属性 |
|----------|----------|
| `SERVER_PORT` | `server.port` |
| `SPRING_DATASOURCE_URL` | `spring.datasource.url` |
| `APP_CACHE_ENABLED` | `app.cache.enabled` |
| `APP_PAYMENT_TIMEOUT` | `app.payment.timeout` |

### 3. 复杂配置的环境变量

#### 嵌套属性
```bash
# 对应配置：app.payment.providers.alipay.enabled=true
export APP_PAYMENT_PROVIDERS_ALIPAY_ENABLED=true

# 对应配置：app.external-services.payment.timeout=30000
export APP_EXTERNAL_SERVICES_PAYMENT_TIMEOUT=30000
```

#### 数组和列表
```bash
# 对应配置：app.servers[0].name=server1
export APP_SERVERS_0_NAME=server1
export APP_SERVERS_0_HOST=192.168.1.10
export APP_SERVERS_0_PORT=8080

# 对应配置：app.servers[1].name=server2
export APP_SERVERS_1_NAME=server2
export APP_SERVERS_1_HOST=192.168.1.11
export APP_SERVERS_1_PORT=8080
```

#### 复杂对象
```bash
# 对应配置：app.security.jwt-secret=your-secret-key
export APP_SECURITY_JWT_SECRET=your-secret-key

# 对应配置：app.cache.providers[0]=redis
export APP_CACHE_PROVIDERS_0=redis
export APP_CACHE_PROVIDERS_1=ehcache
```

### 4. Docker 环境变量示例

```dockerfile
# Dockerfile
FROM openjdk:11-jre-slim

# 设置环境变量
ENV SERVER_PORT=8080
ENV SPRING_PROFILES_ACTIVE=docker
ENV DATABASE_URL=jdbc:mysql://db:3306/myapp
ENV DB_USER=myapp
ENV DB_PASSWORD=${DB_PASSWORD}

COPY target/myapp.jar app.jar
EXPOSE 8080

ENTRYPOINT ["java", "-jar", "/app.jar"]
```

```yaml
# docker-compose.yml
version: '3.8'
services:
  app:
    build: .
    ports:
      - "8080:8080"
    environment:
      - SPRING_PROFILES_ACTIVE=docker
      - DATABASE_URL=jdbc:mysql://mysql:3306/myapp
      - DB_USER=myapp
      - DB_PASSWORD=myapp-secret
      - REDIS_HOST=redis
      - REDIS_PORT=6379
    depends_on:
      - mysql
      - redis

  mysql:
    image: mysql:8.0
    environment:
      - MYSQL_ROOT_PASSWORD=root-secret
      - MYSQL_DATABASE=myapp
      - MYSQL_USER=myapp
      - MYSQL_PASSWORD=myapp-secret
    volumes:
      - mysql_data:/var/lib/mysql

  redis:
    image: redis:6.2-alpine
    volumes:
      - redis_data:/data

volumes:
  mysql_data:
  redis_data:
```

---

## 命令行参数配置

### 1. 基本命令行参数

```bash
# 简单参数
java -jar myapp.jar --server.port=9090

# 多个参数
java -jar myapp.jar \
  --server.port=9090 \
  --spring.profiles.active=prod \
  --app.name="My Production App"

# 带空格的值需要引号
java -jar myapp.jar --app.description="My Application with spaces"
```

### 2. 特殊字符处理

```bash
# 包含特殊字符的值
java -jar myapp.jar --db.password="p@ssw0rd!#"

# JSON 格式的配置
java -jar myapp.jar --app.config='{"timeout":30000,"retries":3}'

# 列表配置
java -jar myapp.jar --app.servers="server1,server2,server3"
```

### 3. 禁用命令行参数

```java
@SpringBootApplication
public class MyApplication {
    public static void main(String[] args) {
        SpringApplication app = new SpringApplication(MyApplication.class);
        app.setAddCommandLineProperties(false); // 禁用命令行参数
        app.run(args);
    }
}
```

### 4. 命令行参数与 Spring Boot Actuator

```bash
# 运行时查看配置
curl http://localhost:8080/actuator/configprops

# 运行时修改配置（需要支持）
curl -X POST http://localhost:8080/actuator/env \
  -d "server.port=9090" \
  -H "Content-Type: application/x-www-form-urlencoded"
```

---

## JVM系统属性

### 1. 设置系统属性

#### 通过命令行设置
```bash
java -Dserver.port=9090 \
     -Dspring.profiles.active=prod \
     -Dapp.name="My Application" \
     -jar myapp.jar
```

#### 在代码中设置
```java
@SpringBootApplication
public class MyApplication {
    public static void main(String[] args) {
        // 在启动前设置系统属性
        System.setProperty("server.port", "9090");
        System.setProperty("spring.profiles.active", "prod");

        SpringApplication.run(MyApplication.class, args);
    }
}
```

### 2. 系统属性访问

```java
@Component
public class SystemPropertyReader {

    @Value("#{systemProperties['server.port']}")
    private String serverPort;

    @Value("#{systemProperties['java.version']}")
    private String javaVersion;

    @PostConstruct
    public void printSystemProperties() {
        System.out.println("Server Port: " + serverPort);
        System.out.println("Java Version: " + javaVersion);

        // 直接访问系统属性
        String userHome = System.getProperty("user.home");
        String osName = System.getProperty("os.name");

        System.out.println("User Home: " + userHome);
        System.out.println("OS Name: " + osName);
    }
}
```

### 3. 常用系统属性

```bash
# Java 相关
java.version
java.home
user.home
user.name
user.dir

# 应用相关
server.port
spring.profiles.active
logging.config
spring.config.location
```

---

## 配置文件位置

### 1. 默认配置文件位置

Spring Boot 会按以下顺序查找配置文件：

1. `file:./config/` - 当前目录下的 config 目录
2. `file:./` - 当前目录
3. `classpath:/config/` - classpath 下的 config 目录
4. `classpath:/` - classpath 根目录

### 2. 自定义配置文件位置

#### 通过 spring.config.location
```bash
# 完全替换默认位置
java -jar myapp.jar --spring.config.location=classpath:/custom/,file:/opt/app/config/

# 添加额外位置
java -jar myapp.jar --spring.config.additional-location=file:/opt/app/override/
```

#### 通过配置文件指定
```yaml
spring:
  config:
    location: classpath:/default/,file:/opt/app/config/
    additional-location: file:/opt/app/override/
```

### 3. 配置文件目录结构示例

```
/opt/app/
├── config/
│   ├── application.yml              # 主配置文件
│   ├── application-prod.yml         # 生产环境配置
│   ├── secrets.yml                  # 敏感信息配置
│   └── external/
│       ├── payment.yml              # 支付服务配置
│       └── notification.yml          # 通知服务配置
├── override/                        # 覆盖配置
│   └── application.yml
└── logs/                            # 日志目录
```

### 4. 多配置文件加载

```java
@SpringBootApplication
public class MyApplication {
    public static void main(String[] args) {
        SpringApplication app = new SpringApplication(MyApplication.class);

        // 设置额外的配置文件位置
        app.setAdditionalProfiles("external", "secrets");

        // 设置配置文件位置
        Properties props = new Properties();
        props.setProperty("spring.config.location",
            "classpath:/application.yml," +
            "file:/opt/app/config/application.yml," +
            "file:/opt/app/config/secrets.yml");

        app.setDefaultProperties(props);
        app.run(args);
    }
}
```

---

## 外部化配置最佳实践

### 1. 配置分层策略

```yaml
# application.yml - 基础配置
spring:
  application:
    name: myapp
  profiles:
    active: ${SPRING_PROFILES_ACTIVE:dev}

server:
  port: ${SERVER_PORT:8080}

app:
  name: MyApplication
  version: @project.version@

# application-dev.yml - 开发环境
spring:
  config:
    activate:
      on-profile: dev

  datasource:
    url: jdbc:h2:mem:devdb
    username: sa
    password:

# application-prod.yml - 生产环境
spring:
  config:
    activate:
      on-profile: prod

  datasource:
    url: ${DATABASE_URL}
    username: ${DB_USER}
    password: ${DB_PASSWORD}

logging:
  file:
    name: ${LOG_FILE:/var/log/myapp/application.log}
```

### 2. 敏感信息管理

#### 使用环境变量
```yaml
# 不要在配置文件中硬编码敏感信息
spring:
  datasource:
    password: ${DB_PASSWORD}

  redis:
    password: ${REDIS_PASSWORD}

app:
  security:
    jwt-secret: ${JWT_SECRET}
    encryption-key: ${ENCRYPTION_KEY}
```

#### 使用 Docker Secrets
```yaml
# docker-compose.yml
version: '3.8'
services:
  app:
    image: myapp:latest
    secrets:
      - db_password
      - jwt_secret
    environment:
      - DB_PASSWORD_FILE=/run/secrets/db_password
      - JWT_SECRET_FILE=/run/secrets/jwt_secret

secrets:
  db_password:
    file: ./secrets/db_password.txt
  jwt_secret:
    file: ./secrets/jwt_secret.txt
```

### 3. 配置验证

```java
@Component
@ConfigurationProperties(prefix = "app")
@Data
@Validated
public class AppProperties {

    @NotBlank
    private String name;

    @Pattern(regexp = "^\\d+\\.\\d+\\.\\d+$")
    private String version;

    @Valid
    private final Database database = new Database();

    @Data
    public static class Database {
        @NotBlank
        @Value("${app.database.url}")
        private String url;

        @Min(1)
        @Max(100)
        private int maxConnections = 10;
    }

    @EventListener(ApplicationReadyEvent.class)
    public void validateConfiguration() {
        // 自定义验证逻辑
        if (database.getUrl().contains("localhost") &&
            Arrays.asList(environment.getActiveProfiles()).contains("prod")) {
            throw new IllegalStateException("生产环境不能使用 localhost 数据库");
        }
    }
}
```

### 4. 配置热更新

```java

@RestController
@RequestMapping("/com/cmliy/springweb/config")
public class ConfigurationController {

    @Autowired
    private Environment environment;

    @Autowired
    private ConfigurableApplicationContext context;

    @GetMapping("/refresh")
    public Map<String, Object> refreshConfig() {
        // 刷新配置（需要 spring-cloud-starter-config）
        Map<String, Object> result = new HashMap<>();

        // 获取当前配置
        result.put("server.port", environment.getProperty("server.port"));
        result.put("spring.profiles.active", environment.getProperty("spring.profiles.active"));

        return result;
    }

    @PostMapping("/update")
    public String updateConfig(@RequestParam String key, @RequestParam String value) {
        // 动态更新配置（需要支持）
        System.setProperty(key, value);
        return "Configuration updated: " + key + " = " + value;
    }
}
```

### 5. 配置文档化

```yaml
# application.yml
# =============================================================================
# MyApplication Configuration
# =============================================================================
# This file contains the configuration for MyApplication.
#
# Environment Variables:
#   - SERVER_PORT: Server port (default: 8080)
#   - SPRING_PROFILES_ACTIVE: Active profile (default: dev)
#   - DATABASE_URL: Database connection URL
#   - DB_USER: Database username
#   - DB_PASSWORD: Database password
# =============================================================================

spring:
  # Application basic configuration
  application:
    name: myapp

  # Profile configuration
  profiles:
    active: ${SPRING_PROFILES_ACTIVE:dev}

# Server configuration
server:
  port: ${SERVER_PORT:8080}
  servlet:
    context-path: /api

# Application specific configuration
app:
  # Application name for logging and monitoring
  name: MyApplication

  # Application version (from build)
  version: @project.version@

  # Feature flags
  features:
    # Enable caching feature
    cache-enabled: ${APP_CACHE_ENABLED:true}

    # Enable debug mode
    debug: ${APP_DEBUG:false}
```

### 6. 容器化部署配置

#### Kubernetes ConfigMap
```yaml
# k8s-configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: myapp-config
data:
  application.yml: |
    server:
      port: 8080
    spring:
      profiles:
        active: kubernetes
    app:
      name: MyApp-K8s
      cache:
        enabled: true
```

#### Kubernetes Secret
```yaml
# k8s-secret.yaml
apiVersion: v1
kind: Secret
metadata:
  name: myapp-secrets
type: Opaque
data:
  db-password: bXlzZWNyZXRwYXNzd29yZA==  # base64 encoded
  jwt-secret: bXlqd3RzZWNyZXRrZXk=
```

#### Kubernetes Deployment
```yaml
# k8s-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp
spec:
  template:
    spec:
      containers:
      - name: myapp
        image: myapp:latest
        ports:
        - containerPort: 8080
        env:
        - name: SPRING_PROFILES_ACTIVE
          value: "kubernetes"
        - name: DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: myapp-secrets
              key: db-password
        volumeMounts:
        - name: config-volume
          mountPath: /app/config
      volumes:
      - name: config-volume
        configMap:
          name: myapp-config
```

---

## 总结

### 外部化配置对比

| 配置源 | 优先级 | 适用场景 | 优点 | 缺点 |
|--------|--------|----------|------|------|
| **命令行参数** | 最高 | 临时配置、测试 | 灵活性高、易于测试 | 容易泄露敏感信息 |
| **系统属性** | 高 | JVM级别配置 | 细粒度控制 | 需要重启生效 |
| **环境变量** | 中高 | 容器化部署 | 安全、跨平台 | 命名规则复杂 |
| **外部配置文件** | 中 | 传统部署 | 结构清晰、易管理 | 文件路径依赖 |
| **内部配置文件** | 低 | 默认配置 | 简单方便 | 需要重新打包 |

### 最佳实践总结

1. **分层配置管理**：基础配置 + 环境配置 + 敏感配置分离
2. **敏感信息外部化**：使用环境变量或密钥管理系统
3. **配置验证**：确保配置的完整性和正确性
4. **配置文档化**：提供清晰的配置说明和示例
5. **容器化适配**：支持 Docker、Kubernetes 等容器化部署
6. **配置热更新**：在需要时支持运行时配置更新

记住：**好的外部化配置策略应该让应用具备"一次构建，多处运行"的能力，同时保证配置的安全性和可维护性。**

---

## 相关学习笔记

- [[01-基础配置(@Configuration,@Bean等)]] - 基础配置注解详解
- [[02-属性配置(Properties,YAML,Environment等)]] - 属性和环境配置详解
- [[03-自动配置(@EnableAutoConfiguration,@Conditional等)]] - Spring Boot自动配置机制

## 相关技术文档

- Spring Boot外部化配置 - 官方文档详解
- 配置属性绑定 - @ConfigurationProperties使用指南
- 容器化配置管理 - Docker和Kubernetes配置最佳实践